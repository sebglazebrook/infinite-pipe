#!/bin/bash
# history -r ~/.seb_history

self=`basename "$0"`

declare -a inputs

input_index=0

while read line; do
  echo "$line"
  inputs[input_index]=$line
  input_index=$((input_index + 1))
done

# store stdout
data_dir="/tmp/.infinite-pipe.d"
mkdir -p $data_dir
utc=$(date +"%s")
filename="${data_dir}/$utc"
printf '%s\n' "${inputs[@]}" > $filename

# read user's input
read -e -p $'\e[32m>>\e[0m ' response </dev/tty
if [ -n "${response}" ]; then # inverse -n  => of the length if "STRING" is non-zero.

  # check if the user want to go back
  if [ "${response}" == "back" ]; then
    rm $filename # delete current stdout
    previous_stdout="${data_dir}/$(ls -a "${data_dir}" | tail -n 1)"
    cat $previous_stdout | $self # send through old stdout to pipe
  else
    cat $filename | eval "$response" | $self # send through stdout to the next command
  fi

fi

# read command line args
# start program
# capture any piped input ( on thread?? )
# print out a prompt and wait for the user's command
# parse the command
# if they want to exit -> exit and append to history if set
# otherwise run the command sending in the piped input to the command unless they ask otherwise
